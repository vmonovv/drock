import { joinURL, isEqual } from "ufo";
import { isString, isFunction, isObject } from "@intlify/shared";
import { navigateTo, useNuxtApp, useRouter, useRuntimeConfig, useState } from "#imports";
import {
  nuxtI18nOptionsDefault,
  NUXT_I18N_MODULE_ID,
  isSSG,
  localeLoaders,
  normalizedLocales,
  nuxtI18nOptions
} from "#build/i18n.options.mjs";
import {
  wrapComposable,
  detectBrowserLanguage,
  callVueI18nInterfaces,
  getVueI18nPropertyValue,
  defineGetter,
  getLocaleDomain,
  getDomainFromLocale,
  DefaultDetectBrowserLanguageFromResult
} from "./internal.mjs";
import { loadLocale, makeFallbackLocaleCodes } from "./messages.mjs";
import {
  localeHead,
  localePath,
  localeRoute,
  getRouteBaseName,
  switchLocalePath,
  DefaultPrefixable,
  DefaultSwitchLocalePathIntercepter
} from "./routing/compatibles/index.mjs";
import { getLocale, setLocale, getLocaleCodes, getI18nTarget } from "./routing/utils.mjs";
export function _setLocale(i18n, locale) {
  return callVueI18nInterfaces(i18n, "setLocale", locale);
}
export function setCookieLocale(i18n, locale) {
  return callVueI18nInterfaces(i18n, "setLocaleCookie", locale);
}
export function setLocaleMessage(i18n, locale, messages) {
  return callVueI18nInterfaces(i18n, "setLocaleMessage", locale, messages);
}
export function mergeLocaleMessage(i18n, locale, messages) {
  return callVueI18nInterfaces(i18n, "mergeLocaleMessage", locale, messages);
}
function onBeforeLanguageSwitch(i18n, oldLocale, newLocale, initial, context) {
  return callVueI18nInterfaces(i18n, "onBeforeLanguageSwitch", oldLocale, newLocale, initial, context);
}
export function onLanguageSwitched(i18n, oldLocale, newLocale) {
  return callVueI18nInterfaces(i18n, "onLanguageSwitched", oldLocale, newLocale);
}
export async function finalizePendingLocaleChange(i18n) {
  return callVueI18nInterfaces(i18n, "finalizePendingLocaleChange");
}
export function initCommonComposableOptions(i18n) {
  return {
    i18n: i18n ?? useNuxtApp().$i18n,
    router: useRouter(),
    runtimeConfig: useRuntimeConfig()
  };
}
export async function loadAndSetLocale(newLocale, i18n, initial = false) {
  const _differentDomains = nuxtI18nOptions.differentDomains ?? nuxtI18nOptionsDefault.differentDomains;
  const skipSettingLocaleOnNavigate = nuxtI18nOptions.skipSettingLocaleOnNavigate ?? nuxtI18nOptionsDefault.skipSettingLocaleOnNavigate;
  const lazy = nuxtI18nOptions.lazy ?? nuxtI18nOptionsDefault.lazy;
  const useCookie = (nuxtI18nOptions.detectBrowserLanguage && nuxtI18nOptions.detectBrowserLanguage.useCookie) ?? nuxtI18nOptionsDefault.detectBrowserLanguage.useCookie;
  const nuxtApp = useNuxtApp();
  let ret = false;
  const oldLocale = getLocale(i18n);
  __DEBUG__ && console.log("setLocale: new -> ", newLocale, " old -> ", oldLocale, " initial -> ", initial);
  if (!newLocale) {
    return [ret, oldLocale];
  }
  if (!initial && _differentDomains) {
    return [ret, oldLocale];
  }
  if (oldLocale === newLocale) {
    return [ret, oldLocale];
  }
  const localeOverride = await onBeforeLanguageSwitch(i18n, oldLocale, newLocale, initial, nuxtApp);
  const localeCodes = getLocaleCodes(i18n);
  if (localeOverride && localeCodes && localeCodes.includes(localeOverride)) {
    if (localeOverride === oldLocale) {
      return [ret, oldLocale];
    }
    newLocale = localeOverride;
  }
  const i18nFallbackLocales = getVueI18nPropertyValue(i18n, "fallbackLocale");
  if (lazy) {
    const setter = (locale, message) => mergeLocaleMessage(i18n, locale, message);
    if (i18nFallbackLocales) {
      const fallbackLocales = makeFallbackLocaleCodes(i18nFallbackLocales, [newLocale]);
      await Promise.all(fallbackLocales.map((locale) => loadLocale(locale, localeLoaders, setter)));
    }
    await loadLocale(newLocale, localeLoaders, setter);
  }
  if (skipSettingLocaleOnNavigate) {
    return [ret, oldLocale];
  }
  if (useCookie) {
    setCookieLocale(i18n, newLocale);
  }
  setLocale(i18n, newLocale);
  await onLanguageSwitched(i18n, oldLocale, newLocale);
  ret = true;
  return [ret, oldLocale];
}
export function detectLocale(route, routeLocaleGetter, vueI18nOptionsLocale, initialLocaleLoader, detectLocaleContext) {
  const { strategy, defaultLocale, differentDomains, detectBrowserLanguage: _detectBrowserLanguage } = nuxtI18nOptions;
  const initialLocale = isFunction(initialLocaleLoader) ? initialLocaleLoader() : initialLocaleLoader;
  __DEBUG__ && console.log("detectLocale: initialLocale -", initialLocale);
  const { ssg, callType, firstAccess, localeCookie } = detectLocaleContext;
  __DEBUG__ && console.log("detectLocale: (ssg, callType, firstAccess) - ", ssg, callType, firstAccess);
  const {
    locale: browserLocale,
    stat,
    reason,
    from
  } = _detectBrowserLanguage ? detectBrowserLanguage(route, vueI18nOptionsLocale, detectLocaleContext, initialLocale) : DefaultDetectBrowserLanguageFromResult;
  __DEBUG__ && console.log(
    "detectLocale: detectBrowserLanguage (browserLocale, stat, reason, from) -",
    browserLocale,
    stat,
    reason,
    from
  );
  if (reason === "detect_ignore_on_ssg") {
    return initialLocale;
  }
  if ((from === "navigator_or_header" || from === "cookie" || from === "fallback") && browserLocale) {
    return browserLocale;
  }
  let finalLocale = browserLocale;
  __DEBUG__ && console.log("detectLocale: finaleLocale first (finaleLocale, strategy) -", finalLocale, strategy);
  if (!finalLocale) {
    if (differentDomains) {
      finalLocale = getLocaleDomain(normalizedLocales);
    } else if (strategy !== "no_prefix") {
      finalLocale = routeLocaleGetter(route);
    } else {
      if (!_detectBrowserLanguage) {
        finalLocale = initialLocale;
      }
    }
  }
  __DEBUG__ && console.log(
    "detectLocale: finaleLocale second (finaleLocale, detectBrowserLanguage) -",
    finalLocale,
    _detectBrowserLanguage
  );
  if (!finalLocale && _detectBrowserLanguage && _detectBrowserLanguage.useCookie) {
    finalLocale = localeCookie.value || "";
  }
  __DEBUG__ && console.log("detectLocale: finalLocale last (finalLocale, defaultLocale) -", finalLocale, defaultLocale);
  if (!finalLocale) {
    finalLocale = defaultLocale || "";
  }
  __DEBUG__ && console.log("detectLocale: finalLocale -", finalLocale);
  return finalLocale;
}
export function detectRedirect({
  route,
  targetLocale,
  routeLocaleGetter,
  calledWithRouting = false
}) {
  const nuxtApp = useNuxtApp();
  const common = initCommonComposableOptions();
  const { strategy, differentDomains } = nuxtI18nOptions;
  __DEBUG__ && console.log("detectRedirect: targetLocale -> ", targetLocale);
  __DEBUG__ && console.log("detectRedirect: route -> ", route);
  __DEBUG__ && console.log("detectRedirect: calledWithRouting -> ", calledWithRouting, routeLocaleGetter(route.to));
  let redirectPath = "";
  const { fullPath: toFullPath } = route.to;
  const isStaticGenerate = isSSG && process.server;
  if (!isStaticGenerate && !differentDomains && (calledWithRouting || strategy !== "no_prefix") && routeLocaleGetter(route.to) !== targetLocale) {
    const routePath = nuxtApp.$switchLocalePath(targetLocale) || nuxtApp.$localePath(toFullPath, targetLocale);
    __DEBUG__ && console.log("detectRedirect: calculate routePath -> ", routePath, toFullPath);
    if (isString(routePath) && routePath && !isEqual(routePath, toFullPath) && !routePath.startsWith("//")) {
      redirectPath = !(route.from && route.from.fullPath === routePath) ? routePath : "";
    }
  }
  if ((differentDomains || isSSG && process.client) && routeLocaleGetter(route.to) !== targetLocale) {
    const routePath = switchLocalePath(common, targetLocale, route.to);
    __DEBUG__ && console.log("detectRedirect: calculate domain or ssg routePath -> ", routePath);
    if (isString(routePath) && routePath && !isEqual(routePath, toFullPath) && !routePath.startsWith("//")) {
      redirectPath = routePath;
    }
  }
  return redirectPath;
}
function isRootRedirectOptions(rootRedirect) {
  return isObject(rootRedirect) && "path" in rootRedirect && "statusCode" in rootRedirect;
}
const useRedirectState = () => useState(NUXT_I18N_MODULE_ID + ":redirect", () => "");
function _navigate(redirectPath, status) {
  return navigateTo(redirectPath, { redirectCode: status });
}
export async function navigate(args, { status = 302, enableNavigate = false } = {}) {
  const rootRedirect = nuxtI18nOptions.rootRedirect ?? nuxtI18nOptionsDefault.rootRedirect;
  const differentDomains = nuxtI18nOptions.differentDomains ?? nuxtI18nOptionsDefault.differentDomains;
  const skipSettingLocaleOnNavigate = nuxtI18nOptions.skipSettingLocaleOnNavigate ?? nuxtI18nOptionsDefault.skipSettingLocaleOnNavigate;
  const { i18n, locale, route } = args;
  let { redirectPath } = args;
  __DEBUG__ && console.log(
    "navigate options ",
    status,
    rootRedirect,
    differentDomains,
    skipSettingLocaleOnNavigate,
    enableNavigate
  );
  __DEBUG__ && console.log("navigate isSSG", isSSG);
  if (route.path === "/" && rootRedirect) {
    if (isString(rootRedirect)) {
      redirectPath = "/" + rootRedirect;
    } else if (isRootRedirectOptions(rootRedirect)) {
      redirectPath = "/" + rootRedirect.path;
      status = rootRedirect.statusCode;
    }
    __DEBUG__ && console.log("navigate: rootRedirect mode redirectPath -> ", redirectPath, " status -> ", status);
    return _navigate(redirectPath, status);
  }
  if (process.client && skipSettingLocaleOnNavigate) {
    i18n.__pendingLocale = locale;
    i18n.__pendingLocalePromise = new Promise((resolve) => {
      i18n.__resolvePendingLocalePromise = resolve;
    });
    if (!enableNavigate) {
      return;
    }
  }
  if (!differentDomains) {
    if (redirectPath) {
      return _navigate(redirectPath, status);
    }
  } else {
    const state = useRedirectState();
    __DEBUG__ && console.log("redirect state ->", state.value, "redirectPath -> ", redirectPath);
    if (state.value && state.value !== redirectPath) {
      if (process.client) {
        state.value = "";
        window.location.assign(redirectPath);
      } else if (process.server) {
        __DEBUG__ && console.log("differentDomains servermode ", redirectPath);
        state.value = redirectPath;
      }
    }
  }
}
export function injectNuxtHelpers(nuxt, i18n) {
  defineGetter(nuxt, "$i18n", getI18nTarget(i18n));
  defineGetter(nuxt, "$getRouteBaseName", getRouteBaseName);
  defineGetter(nuxt, "$localePath", wrapComposable(localePath));
  defineGetter(nuxt, "$localeRoute", wrapComposable(localeRoute));
  defineGetter(nuxt, "$switchLocalePath", wrapComposable(switchLocalePath));
  defineGetter(nuxt, "$localeHead", wrapComposable(localeHead));
}
export function extendPrefixable() {
  return (opts) => {
    return DefaultPrefixable(opts) && !nuxtI18nOptions.differentDomains;
  };
}
export function extendSwitchLocalePathIntercepter() {
  return (path, locale) => {
    if (nuxtI18nOptions.differentDomains) {
      const domain = getDomainFromLocale(locale);
      __DEBUG__ && console.log("extendSwitchLocalePathIntercepter: domain -> ", domain, " path -> ", path);
      if (domain) {
        return joinURL(domain, path);
      } else {
        return path;
      }
    } else {
      return DefaultSwitchLocalePathIntercepter(path, locale);
    }
  };
}
export function extendBaseUrl() {
  return () => {
    const ctx = useNuxtApp();
    const runtimeConfig = useRuntimeConfig();
    const baseUrl = nuxtI18nOptions.baseUrl;
    if (isFunction(baseUrl)) {
      const baseUrlResult = baseUrl(ctx);
      __DEBUG__ && console.log("baseUrl: using localeLoader function -", baseUrlResult);
      return baseUrlResult;
    }
    const localeCodeLoader = nuxtI18nOptions.defaultLocale;
    const localeCode = isFunction(localeCodeLoader) ? localeCodeLoader() : localeCodeLoader;
    if (nuxtI18nOptions.differentDomains && localeCode) {
      const domain = getDomainFromLocale(localeCode);
      if (domain) {
        __DEBUG__ && console.log("baseUrl: using differentDomains -", domain);
        return domain;
      }
    }
    const config = runtimeConfig?.public?.i18n;
    if (config?.baseUrl) {
      __DEBUG__ && console.log("baseUrl: using runtimeConfig -", config.baseUrl);
      return config.baseUrl;
    }
    return baseUrl;
  };
}
export function getNormalizedLocales(locales) {
  const normalized = [];
  for (const locale of locales) {
    if (isString(locale)) {
      normalized.push({ code: locale });
      continue;
    }
    normalized.push(locale);
  }
  return normalized;
}
