import { isArray, isString } from "@intlify/shared";
import { hasProtocol } from "ufo";
import isHTTPS from "is-https";
import {
  useRequestHeaders,
  useRequestEvent,
  useCookie as useNuxtCookie,
  useRuntimeConfig,
  useNuxtApp,
  unref
} from "#imports";
import {
  nuxtI18nOptionsDefault,
  NUXT_I18N_MODULE_ID,
  isSSG,
  localeCodes,
  nuxtI18nOptions,
  normalizedLocales
} from "#build/i18n.options.mjs";
import { findBrowserLocale, getLocalesRegex, getI18nTarget } from "./routing/utils.mjs";
import { initCommonComposableOptions } from "./utils.mjs";
export function formatMessage(message) {
  return NUXT_I18N_MODULE_ID + " " + message;
}
export function callVueI18nInterfaces(i18n, name, ...args) {
  const target = getI18nTarget(i18n);
  const [obj, method] = [target, target[name]];
  return Reflect.apply(method, obj, [...args]);
}
export function getVueI18nPropertyValue(i18n, name) {
  const target = getI18nTarget(i18n);
  return unref(target[name]);
}
export function defineGetter(obj, key, val) {
  Object.defineProperty(obj, key, { get: () => val });
}
export function wrapComposable(fn, common = initCommonComposableOptions()) {
  return (...args) => fn(common, ...args);
}
export function parseAcceptLanguage(input) {
  return input.split(",").map((tag) => tag.split(";")[0]);
}
export function getBrowserLocale() {
  let ret;
  if (process.client) {
    if (navigator.languages) {
      ret = findBrowserLocale(normalizedLocales, navigator.languages);
      __DEBUG__ && console.log("getBrowserLocale (navigator.languages, ret) -", navigator.languages, ret);
    }
  } else if (process.server) {
    const header = useRequestHeaders(["accept-language"]);
    __DEBUG__ && console.log("getBrowserLocale accept-language", header);
    const accept = header["accept-language"];
    if (accept) {
      ret = findBrowserLocale(normalizedLocales, parseAcceptLanguage(accept));
      __DEBUG__ && console.log("getBrowserLocale ret", ret);
    }
  }
  return ret;
}
export function getI18nCookie() {
  const detect = nuxtI18nOptions.detectBrowserLanguage;
  const cookieKey = detect && detect.cookieKey || nuxtI18nOptionsDefault.detectBrowserLanguage.cookieKey;
  const date = /* @__PURE__ */ new Date();
  const cookieOptions = {
    expires: new Date(date.setDate(date.getDate() + 365)),
    path: "/",
    sameSite: detect && detect.cookieCrossOrigin ? "none" : "lax",
    secure: detect && detect.cookieCrossOrigin || detect && detect.cookieSecure
  };
  if (detect && detect.cookieDomain) {
    cookieOptions.domain = detect.cookieDomain;
  }
  return useNuxtCookie(cookieKey, cookieOptions);
}
export function getLocaleCookie(cookieRef) {
  const detect = nuxtI18nOptions.detectBrowserLanguage;
  __DEBUG__ && console.log("getLocaleCookie", {
    useCookie: detect && detect.useCookie,
    cookieKey: detect && detect.cookieKey,
    localeCodes
  });
  if (!detect || !detect.useCookie) {
    return;
  }
  const localeCode = cookieRef.value ?? void 0;
  __DEBUG__ && console.log(`getLocaleCookie cookie (${process.client ? "client" : "server"}) -`, localeCode);
  if (localeCode && localeCodes.includes(localeCode)) {
    return localeCode;
  }
}
export function setLocaleCookie(cookieRef, locale) {
  const { useCookie } = nuxtI18nOptions.detectBrowserLanguage || nuxtI18nOptionsDefault.detectBrowserLanguage;
  if (!useCookie) {
    return;
  }
  cookieRef.value = locale;
}
export const DefaultDetectBrowserLanguageFromResult = {
  locale: "",
  stat: false,
  reason: "unknown",
  from: "unknown"
};
export function detectBrowserLanguage(route, vueI18nOptionsLocale, detectLocaleContext, locale = "") {
  const { strategy } = nuxtI18nOptions;
  const { ssg, callType, firstAccess, localeCookie } = detectLocaleContext;
  __DEBUG__ && console.log("detectBrowserLanguage: (ssg, callType, firstAccess) - ", ssg, callType, firstAccess);
  if (isSSG && strategy === "no_prefix" && (process.server || ssg === "ssg_ignore")) {
    return { locale: "", stat: true, reason: "detect_ignore_on_ssg" };
  }
  if (!firstAccess) {
    return { locale: strategy === "no_prefix" ? locale : "", stat: false, reason: "first_access_only" };
  }
  const { redirectOn, alwaysRedirect, useCookie, fallbackLocale } = nuxtI18nOptions.detectBrowserLanguage;
  const path = isString(route) ? route : route.path;
  __DEBUG__ && console.log(
    "detectBrowserLanguage: (path, strategy, alwaysRedirect, redirectOn, locale) -",
    path,
    strategy,
    alwaysRedirect,
    redirectOn,
    locale
  );
  if (strategy !== "no_prefix") {
    if (redirectOn === "root") {
      if (path !== "/") {
        __DEBUG__ && console.log("detectBrowserLanguage: not root");
        return { locale: "", stat: false, reason: "not_redirect_on_root" };
      }
    } else if (redirectOn === "no prefix") {
      __DEBUG__ && console.log("detectBrowserLanguage: no prefix (path) -", path);
      if (!alwaysRedirect && path.match(getLocalesRegex(localeCodes))) {
        return { locale: "", stat: false, reason: "not_redirect_on_no_prefix" };
      }
    }
  }
  let localeFrom = "unknown";
  let cookieLocale;
  let matchedLocale;
  if (useCookie) {
    matchedLocale = cookieLocale = localeCookie.value;
    localeFrom = "cookie";
    __DEBUG__ && console.log("detectBrowserLanguage: cookieLocale", cookieLocale);
  }
  if (!matchedLocale) {
    matchedLocale = getBrowserLocale();
    localeFrom = "navigator_or_header";
    __DEBUG__ && console.log("detectBrowserLanguage: browserLocale", matchedLocale);
  }
  __DEBUG__ && console.log(
    "detectBrowserLanguage: (matchedLocale, cookieLocale, localeFrom) -",
    matchedLocale,
    cookieLocale,
    localeFrom
  );
  const finalLocale = matchedLocale || fallbackLocale;
  if (!matchedLocale && fallbackLocale) {
    localeFrom = "fallback";
  }
  __DEBUG__ && console.log(
    "detectBrowserLanguage: first finaleLocale (finaleLocale, cookieLocale, localeFrom) -",
    finalLocale,
    cookieLocale,
    localeFrom
  );
  const vueI18nLocale = locale || vueI18nOptionsLocale;
  __DEBUG__ && console.log("detectBrowserLanguage: vueI18nLocale", vueI18nLocale);
  if (finalLocale && (!useCookie || alwaysRedirect || !cookieLocale)) {
    if (strategy === "no_prefix") {
      return { locale: finalLocale, stat: true, from: localeFrom };
    } else {
      if (callType === "setup") {
        if (finalLocale !== vueI18nLocale) {
          __DEBUG__ && console.log("detectBrowserLanguage: finalLocale !== vueI18nLocale", finalLocale);
          return { locale: finalLocale, stat: true, from: localeFrom };
        }
      }
      if (alwaysRedirect) {
        const redirectOnRoot = path === "/";
        const redirectOnAll = redirectOn === "all";
        const redirectOnNoPrefix = redirectOn === "no prefix" && !path.match(getLocalesRegex(localeCodes));
        __DEBUG__ && console.log(
          "detectBrowserLanguage: (redirectOnRoot, redirectOnAll, redirectOnNoPrefix) - ",
          redirectOnRoot,
          redirectOnAll,
          redirectOnNoPrefix
        );
        if (redirectOnRoot || redirectOnAll || redirectOnNoPrefix) {
          return { locale: finalLocale, stat: true, from: localeFrom };
        }
      }
    }
  }
  if (ssg === "ssg_setup" && finalLocale) {
    return { locale: finalLocale, stat: true, from: localeFrom };
  }
  if ((localeFrom === "navigator_or_header" || localeFrom === "cookie") && finalLocale) {
    return { locale: finalLocale, stat: true, from: localeFrom };
  }
  return { locale: "", stat: false, reason: "not_found_match" };
}
export function getHost() {
  let host;
  if (process.client) {
    host = window.location.host;
  } else if (process.server) {
    const header = useRequestHeaders(["x-forwarded-host", "host"]);
    let detectedHost;
    if ("x-forwarded-host" in header) {
      detectedHost = header["x-forwarded-host"];
    } else if ("host" in header) {
      detectedHost = header["host"];
    }
    host = isArray(detectedHost) ? detectedHost[0] : detectedHost;
  }
  return host;
}
export function getLocaleDomain(locales) {
  let host = getHost() || "";
  if (host) {
    const matchingLocale = locales.find((locale) => {
      if (locale && locale.domain) {
        let domain = locale.domain;
        if (hasProtocol(locale.domain)) {
          domain = locale.domain.replace(/(http|https):\/\//, "");
        }
        return domain === host;
      }
      return false;
    });
    if (matchingLocale) {
      return matchingLocale.code;
    } else {
      host = "";
    }
  }
  return host;
}
export function getDomainFromLocale(localeCode) {
  const runtimeConfig = useRuntimeConfig();
  const nuxtApp = useNuxtApp();
  const config = runtimeConfig.public.i18n;
  const lang = normalizedLocales.find((locale) => locale.code === localeCode);
  const domain = config?.locales?.[localeCode]?.domain ?? lang?.domain;
  if (domain) {
    if (hasProtocol(domain, { strict: true })) {
      return domain;
    }
    let protocol;
    if (process.server) {
      const {
        node: { req }
      } = useRequestEvent(nuxtApp);
      protocol = req && isHTTPS(req) ? "https:" : "http:";
    } else {
      protocol = new URL(window.location.origin).protocol;
    }
    return protocol + "//" + domain;
  }
  console.warn(formatMessage("Could not find domain name for locale " + localeCode));
}
